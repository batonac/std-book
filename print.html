<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Standard Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The official book for the &#x60;std&#x60; framework.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded "><a href="getting_started/introduction.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/flake.html"><strong aria-hidden="true">1.1.</strong> A std Flake</a></li><li class="chapter-item expanded "><a href="getting_started/first_block.html"><strong aria-hidden="true">1.2.</strong> Our First Cell Block</a></li><li class="chapter-item expanded "><a href="getting_started/growing.html"><strong aria-hidden="true">1.3.</strong> Growing</a></li><li class="chapter-item expanded "><a href="getting_started/std_tui.html"><strong aria-hidden="true">1.4.</strong> The std TUI</a></li><li class="chapter-item expanded "><a href="getting_started/review.html"><strong aria-hidden="true">1.5.</strong> Review</a></li></ol></li><li class="chapter-item expanded "><a href="devshells/introduction.html"><strong aria-hidden="true">2.</strong> Managing Devshells</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="devshells/devshell_block.html"><strong aria-hidden="true">2.1.</strong> Adding a Devshell Block</a></li><li class="chapter-item expanded "><a href="devshells/direnv.html"><strong aria-hidden="true">2.2.</strong> Integrating direnv</a></li><li class="chapter-item expanded "><a href="devshells/review.html"><strong aria-hidden="true">2.3.</strong> Review</a></li></ol></li><li class="chapter-item expanded "><a href="configs/introduction.html"><strong aria-hidden="true">3.</strong> Managing Configurations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="configs/nixago_block.html"><strong aria-hidden="true">3.1.</strong> Adding a Nixago Block</a></li><li class="chapter-item expanded "><a href="configs/review.html"><strong aria-hidden="true">3.2.</strong> Review</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Standard Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jmgilman/std-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="images/logo.png" alt="std logo" /></p>
<p>Welcome to the <a href="https://github.com/divnix/std"><code>std</code></a> book! This book is intended to serve as a companion
to the <a href="https://divnix.github.io/std/">documentation</a>. The primary difference between the two is that
this book serves as a walk-through for configuring a <code>std</code> environment using an
example Rust project. At the end of this book, you'll have a completely
<em><code>std</code>ized</em> project utilizing all of the main benefits offered by the <code>std</code>
framework.</p>
<h2 id="how-this-book-is-organized"><a class="header" href="#how-this-book-is-organized">How this book is organized</a></h2>
<p>This book is broken up into several chapters. Each chapter tackles a big idea
from <code>std</code> while building on the work done in the previous chapters. As such,
the book is intended to be read from start to finish; however, each chapter is
written in a way that can still be useful as a quick reference.</p>
<p>Since <code>std</code> is a <a href="https://nixos.org">Nix</a> framework and is intended to be used to organize code
repositories, it makes sense to work through applying it to an example project.
In this book, we're using a very basic Rust project, for which the source code
can be <a href="https://github.com/jmgilman/std-book/tree/master/rust">found here</a>.</p>
<p>Throughout the book, we'll be building out an environment that uses the above
example project. The final source code for the completed example project can be
<a href="https://github.com/jmgilman/std-book-example">found here</a>.</p>
<h2 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h2>
<p>There are a few assumptions about the reader of this book:</p>
<ol>
<li>The reader is already familiar with <a href="https://nixos.org">Nix</a>. While all code snippets will be
clearly explained, none of the explanations will be focused on language
constructs.</li>
<li>The reader has experience working with <a href="https://nixos.wiki/wiki/Flakes">Nix flakes</a>.</li>
<li>The reader has general experience working within a code repository, including
the common tasks and processes that occur within.</li>
</ol>
<p>It's worth noting that you <strong>do not</strong> need experience with the <a href="https://www.rust-lang.org">Rust
language</a>. The usage of Rust is for example purposes only.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>The <a href="https://github.com/divnix/std"><code>std</code></a> (short for standard) framework is an opinionated <a href="https://nixos.org">Nix</a>
<a href="https://nixos.wiki/wiki/Flakes">flakes</a> framework that aims to solve the problem of complexity that
often arises in large Nix-based projects. It's opinionated because it prescribes
a standard, flake-based structure for repositories using Nix. It eliminates the
question of <em>how</em> Nix code should be organized and ultimately serves as a boon
for productivity.</p>
<p>In this chapter, we will briefly introduce the framework as a whole. As a
reminder, this book will be starting off with an <a href="https://github.com/jmgilman/std-book/tree/master/rust">example Rust project</a>
and then slowly integrating the <code>std</code> framework into it. It's recommended you
clone the repository locally and follow along with the book for the best
learning experience.</p>
<p>The Rust project is intentionally barebones as it's not the primary focus of the
book. As a quick overview, the project produces a single binary that takes one
argument and uses it to print a string in the format of, <code>Hello, &lt;arg&gt;!</code>. It
contains a single unit test that confirms the above logic works as expected.</p>
<h2 id="why-std"><a class="header" href="#why-std">Why Std?</a></h2>
<p><code>std</code> aims to provide a rigid framework for organizing Nix code in a repository.
Why is this even necessary? The primary reason is that, because Nix can more or
less do anything, it tends to become progressively less organized the more lines
of it you add to your repository. While flakes helped to bring some organization
to the entry point of a Nix environment, it also disrupted it in other ways
(i.e., what to do with <code>system</code>). In the case of a monorepo, this nature can
quickly become crippling and often results in all sorts of unique &quot;frameworks&quot;
being developed by each team to address it.</p>
<p>For these reasons, <code>std</code> was developed to help reign in large Nix codebases.
However, it's not only for large projects. As we'll see in this article, it can
be used in projects of any size and will naturally grow along with them. Indeed,
this is the preferred approach because it tackles the complexity before it has a
chance to grow too unwieldy.</p>
<h2 id="std-organization"><a class="header" href="#std-organization">Std Organization</a></h2>
<pre class="mermaid">%%{ init : { &quot;flowchart&quot; : { &quot;curve&quot; : &quot;linear&quot; }}}%%

flowchart TD
    repository(Repository)
    cell1(Cell)
    cell2(Cell)
    cellblock1(Cell Block)
    cellblock2(Cell Block)
    cellblock3(Cell Block)
    cellblock4(Cell Block)
    repository --&gt; cell1
    repository --&gt; cell2
    cell1 --&gt; cellblock1
    cell1 --&gt; cellblock2
    cell2 --&gt; cellblock3
    cell2 --&gt; cellblock4
</pre>
<p>The <code>std</code> framework is broken up into three organizational levels:</p>
<ul>
<li><strong>Repository</strong>: This might seem like a given, but the repository serves as the
highest level of organization within std. One could consider it an organism
made up of one or more cells.</li>
<li><strong>Cell</strong>: The largest organizational unit, a cell typically encompasses a
single component of a repository. In a monorepo, there could be one cell per
service/binary in the repository. An entire cell could be dedicated to the
automation within a repository for smaller projects.</li>
<li><strong>Cell block</strong>: A cell block is a subcomponent of a cell and serves to further
subdivide a cell into smaller components. In particular, cell blocks are
typed, meaning each falls within a category that defines the functionality the
cell block provides. The meaning of this will become more apparent later on.</li>
</ul>
<p>It's worth noting that cell blocks were previously referred to as organelles,
and cell block types were referred to as clades. These have recently changed to
ease adoption.</p>
<p>While the presence of cells and cell blocks helps to define an organizational
framework, at the same time, the ambiguity as to how cells should be organized
provides a necessary degree of flexibility. In this book, we'll give a sample
cell structure for our project, but the method proposed here is by no means the
best one for every project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-std-flake"><a class="header" href="#a-std-flake">A <code>std</code> Flake</a></h1>
<p>The starting point for integrating <code>std</code> with our example project is defining a
<code>flake.nix</code> file at the root of our repository. As mentioned previously, <code>std</code>
is a <em>flake-based</em> framework, and usage of Nix flakes is not optional.</p>
<p>Throughout this book, we'll be sharing snippets of our growing integration.
These snippets will make excessive use of localized comments to explain
concepts, as the proximity of these tends to make explanations much more
effective. As our code base grows, repeat code will have comments stripped and
only the new additions will be commented.</p>
<h2 id="our-std-flake"><a class="header" href="#our-std-flake">Our <code>std</code> Flake</a></h2>
<pre><code class="language-nix">{
  # Like any flake, we define a set of inputs that should be accessible to our
  # project. Here, we include the `std` library and the latest version of
  # nixpkgs.
  inputs.std.url = &quot;github:divnix/std&quot;;
  inputs.nixpkgs.url = &quot;nixpkgs&quot;;

  # As per the flake schema, we define an attribute for holding the outputs of
  # our flake. In this case, `std` will be responsible for managing the outputs.
  outputs = { std, ... } @ inputs:
    # The `growOn` function can be seen as the main entrypoint into `std`. It is
    # responsible for growing our &quot;organism&quot; through cells into the final
    # product. It will produce an output schema that is specific to `std` and
    # can be further explored through the `std` CLI/TUI.
    #
    # The `growOn` function is similar to `grow` but allows us to expand our
    # flake outputs to include more than just what `std` generates by default.
    # It takes a variable number of attribute sets after the first one which
    # defines how it behaves and will recursively update them into one final
    # set. Without this, we would only be able to use the `std` CLI/TUI, as by
    # default `std` places outputs under the `__std` attribute which the nix CLI
    # knows nothing about.
    std.growOn
      {
        # Necessary for `std` to perform its magic.
        inherit inputs;

        # This is one of the most important arguments for the `grow` function.
        # It defines the path where `std` will search for our cells. In this
        # case, we're specifying the `nix` subdirectory. A cell, in this case,
        # would be defined in a subdirectory under `nix` (i.e. ./nix/cell).
        cellsFrom = ./nix;

        # This is the second most important argument for the `grow` function. It
        # informs `std` of the block types that exist within our cells and where
        # they can be found. In this case, we're specifying that we have
        # &quot;runnable&quot; block types that can be found in an `apps.nix` file under
        # the cell directory.
        #
        # The `std` framework has many different block types, and they primarily
        # dictate how the `std` CLI/TUI will behave. For example, the `runnable`
        # type will allow us to run our cell block as an executable using:
        #
        # &gt; std //std-example/apps/default:run
        #
        # The `run` action is available because we've specified the `runnable`
        # cell block type. In this case, we're running the `default` target
        # which is defined as a derivation in ./nix/std-example/apps.nix that
        # builds our binary.
        cellBlocks = [
          (std.blockTypes.runnables &quot;apps&quot;)
        ];
      }
      # This second argument, as described above, allows us to expand what gets
      # included in our flake output. In this case, we're using the built-in
      # `harvest` function to &quot;harvest&quot; the derivations from our apps cell
      # block into the `packages` attribute of our flake output. This allows us
      # to interact with our flake using the nix CLI. For example, we can run
      #
      # &gt; nix run .#default
      #
      # Which will build and run our binary.
      {
        packages = std.harvest inputs.self [ [ &quot;example&quot; &quot;apps&quot; ] ];
      };
}
</code></pre>
<p>Much of the structure presented above should not be surprising as there is no
major deviation from the <a href="https://nixos.wiki/wiki/Flakes#Flake_schema">expected flake schema</a>. Perhaps the
largest change occurs in that this structure is primarily generated by <code>std</code>
through the <a href="https://github.com/divnix/std/blob/main/src/grow-on.nix"><code>grow-on</code> function</a>. The arguments for this function are
where we primarily derive the structure we discussed in the
<a href="getting_started/introduction.html">previous chapter</a>. Of note are the following:</p>
<ul>
<li><code>cellsFrom</code>: The cells that make up our <em>organism</em> must be defined in a single
folder within our repository. It's idiomatic to name this folder either
<code>cells</code> or <code>nix</code>. Within this directory, each cell is isolated into a
subdirectory, with all of its cell blocks further nested under this
subdirectory.</li>
<li><code>cellBlock</code>: Each cell consists of one or more blocks which are defined here
in list form. Recall that cell blocks are <em>typed</em>, and the general format for
defining them is <code>(std.blockTypes.&lt;type&gt; &quot;&lt;name&gt;&quot;)</code>; where <code>&lt;type&gt;</code> is a valid
block type as <a href="https://github.com/divnix/std/tree/main/src/blocktypes">defined here</a> and <code>&lt;name&gt;</code> is where <code>std</code> should
look for the cell block under the parent cell's folder.</li>
</ul>
<p>With these two arguments, we can bring cohesion to our otherwise disunified Nix
code. We know where cells are defined, what block types are available, and where
to find them. Determining where our <em>runnables</em> exist is simply a matter of
examining our <code>flake.nix</code> and following the paths accordingly.</p>
<p>The <code>growOn</code> function takes a variadic number of additional arguments and is
what differentiates it from its <a href="https://github.com/divnix/std/blob/main/src/grow.nix">sibling function</a> (<code>grow</code>). We will dive
deeper into these additional arguments in a future chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="our-first-cell-block"><a class="header" href="#our-first-cell-block">Our First Cell Block</a></h1>
<p>The flake, by itself, is not sufficient for a working example. We've told <code>std</code>
that our cells have <code>runnable</code> blocks, yet we've neither created the cell nor
defined any blocks.</p>
<p>To resolve this, we'll create a new file: <code>./nix/example/apps.nix</code>.</p>
<ul>
<li><code>./nix/</code>: Defined in our <code>cellsFrom</code> argument in the <code>flake.nix</code></li>
<li><code>./example/</code>: The name of our cell.</li>
<li><code>apps.nix</code>: The name of our cell block.</li>
</ul>
<p>Hopefully, the <code>std</code> structure is starting to become natural now. Here are the
contents of our file:</p>
<pre><code class="language-nix"># A common `std` idiom is to place all buildables for a cell in a `apps.nix`
# cell block. This is not required, and you can name this cell block anything
# that makes sense for your project.
#
# This cell block is used to define how our example application is built.
# Ultimately, this means it produces a nix derivation that, when evalulated,
# produces our binary.

# The function arguments shown here are universal to all cell blocks. We are
# provided with the inputs from our flake and a `cell` attribute which refers
# to the parent cell this block falls under. Note that the inputs are
# &quot;desystematized&quot; and are not in the same format as the `inputs` attribute in
# the flake. This is a key benefit afforded by `std`.
{ inputs
, cell
}:
let
  # The `inputs` attribute allows us to access all of our flake inputs.
  inherit (inputs) nixpkgs std;

  # This is a common idiom for combining lib with builtins.
  l = nixpkgs.lib // builtins;
in
{
  # We can think of this attribute set as what would normally be contained under
  # `outputs.packages` in our flake.nix. In this case, we're defining a default
  # package which contains a derivation for building our binary.
  default = with inputs.nixpkgs; rustPlatform.buildRustPackage {
    pname = &quot;example&quot;;
    version = &quot;0.1.0&quot;;

    # `std` includes some useful helper functions, one of which is `incl` which
    # handles filtering out unwanteed files from our package src. The benefit
    # here is it reduces unecessary builds by limiting the input files of our
    # derivation to only those that are needed to build it.
    src = std.incl (inputs.self) [
      (inputs.self + /Cargo.toml)
      (inputs.self + /Cargo.lock)
      (inputs.self + /src)
    ];
    cargoLock = {
      lockFile = inputs.self + &quot;/Cargo.lock&quot;;
    };

    meta = {
      description = &quot;An example Rust binary which greets the user&quot;;
    };
  };
}
</code></pre>
<h2 id="standardized-arguments"><a class="header" href="#standardized-arguments">Standardized Arguments</a></h2>
<p>One of the major benefits of <code>std</code> can be seen in the first few lines of Nix
code. As is fairly typical with Nix, the file serves as one large function;
however, the significance of the argument structure can be easily overlooked.
This structure can be viewed as the <em>standardized</em> form of all cell blocks. From
these two arguments, it's possible to derive <em>all</em> values required to perform
our required logic.</p>
<p>Again, this cannot be overstated: we define the arguments the same way each time
and are guaranteed access to all of the tools and data required to perform our
logic. Historically, passing around information in Nix has been a major pain
point. The further down the rabbit hole we go, the more difficult it is to bring
the required information to perform the tasks at the bottom. We can visualize
the benefit <code>std</code> brings here with a small table:</p>
<div class="table-wrapper"><table><thead><tr><th>type</th><th><code>inputs</code></th><th><code>cell</code></th><th><code>inputs.cells</code></th></tr></thead><tbody>
<tr><td>packages</td><td><code>inputs.nixpkgs</code></td><td><code>cell.runnables</code></td><td><code>inputs.cells.*.runnable</code></td></tr>
<tr><td>functions</td><td><code>inputs.nixpkgs.lib</code></td><td><code>cell.functions</code></td><td><code>inputs.cells.*.functions</code></td></tr>
<tr><td>...</td><td><code>inputs.*</code></td><td><code>cell.*</code></td><td><code>inputs.cells.*.*</code></td></tr>
</tbody></table>
</div>
<p>With this structure, we can access all of our flake inputs (including
<code>nixpkgs</code>), all local cell blocks, and even cell blocks from sibling cells. No
matter how large our project grows, the same pattern for traversing it will be
maintained.</p>
<h2 id="standardized-package-definitions"><a class="header" href="#standardized-package-definitions">Standardized Package Definitions</a></h2>
<p>The remainder of the file should look familiar to those attuned to Nix. It's
nothing more than an attribute set where the name is a package name and the
value is a derivation. This section, of course, benefits from our standardized
arguments because we can easily access everything we need to build a proper
derivation for our Rust binary.</p>
<p>In addition to the above, <code>std</code> also ships with some useful helper functions for
performing standard Nix operations. In our example, we utilize <code>std.include</code> to
filter out the source files for our project. Since derivations are hashed based
on their inputs, limiting inputs is the best practice to maximize cache usage
and avoid the unnecessary rebuilding of our binary.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="growing"><a class="header" href="#growing">Growing</a></h1>
<p>It's important to take a small detour at this point and explore the
<code>std.grow</code>/<code>std.growOn</code> functions in detail. In particular, it helps to inspect
the output of our flake to better understand what it is that these <code>grow</code>
functions are generating.</p>
<p>If we refer back to <a href="getting_started/flake.html#our-std-flake">our flake</a>, we will recall that we
used the <code>growOn</code> function for generating the flake output. Let's assume for a
second that we instead chose to use the <code>std.grow</code> function. If we were to
inspect our flake output at this point, we would see something similar to this:</p>
<pre><code class="language-text">$ nix flake show
git+file:///Users/josh/code/std-book-example
├───__std: unknown
├───aarch64-darwin: unknown
├───aarch64-linux: unknown
├───x86_64-darwin: unknown
└───x86_64-linux: unknown
</code></pre>
<p>This looks strange at first; what is under <code>__std</code>? This attribute is generated
by the grow functions and is referred to as the <em>registry</em>. It houses a plethora
of information about our standardized environment, and you can inspect what's
under here by running:</p>
<pre><code class="language-text">nix eval --json .#__std | jq
</code></pre>
<p>The output is large, so it will be omitted here, but essentially it describes
our entire environment, including what cells we have, the blocks (and their
types) of those cells, what actions we can run on the blocks, etc. The benefit
here is that it provides a layer by which external tools can utilize the
information gathered about our environment.</p>
<p>What about all the unknowns? There is data here, but it's important to
understand that it doesn't conform to the expected flake output schema, so
<code>nix flake show</code> just marks it as &quot;unknown.&quot; Again, we can see the structure by
going into the Nix REPL environment:</p>
<pre><code class="language-text">$ nix repl
Welcome to Nix 2.10.3. Type :? for help.

nix-repl&gt; :lf .
Added 18 variables.

nix-repl&gt; :p aarch64-darwin
{ std-example = { apps = { default = «derivation /nix/store/rb7jvsds8wxcrxzfz8cc7jpgqsxch8w1-std-example-0.1.0.drv»; }; }; }
</code></pre>
<p>In other words, we could run our binary using:</p>
<pre><code class="language-text">$ nix run .#aarch64-darwin.std-example.apps.default world
Hello, world!
</code></pre>
<p>However, this isn't very intuitive, and this is why the <code>growOn</code> function
becomes helpful. It allows us to add a compatibility layer by transforming the
above structure into something that the Nix CLI can more easily understand. In
our case, if we run the same <code>nix flake show</code> command with the <code>growOn</code>
function, we see:</p>
<pre><code class="language-text">$ nix flake show
git+file:///Users/josh/code/std-book-example
├───__functor: unknown
├───__std: unknown
├───aarch64-darwin: unknown
├───aarch64-linux: unknown
├───packages
│   ├───aarch64-darwin
│   │   └───default: package 'example-0.1.0'
│   ├───aarch64-linux
│   │   └───default: package 'example-0.1.0'
│   ├───x86_64-darwin
│   │   └───default: package 'example-0.1.0'
│   └───x86_64-linux
│       └───default: package 'example-0.1.0'
├───x86_64-darwin: unknown
└───x86_64-linux: unknown
</code></pre>
<p>This now allows us to run our binary using:</p>
<pre><code class="language-text">$ nix run .#default world
Hello, world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-std-tui"><a class="header" href="#the-std-tui">The <code>std</code> TUI</a></h1>
<p>There's one final thing we have gained from our work so far. The <code>std</code> framework
ships with a binary that adds a terminal user interface (TUI) to our project.
The quickest way to experiment with it is to enter a <code>nix-shell</code> with the
package installed:</p>
<pre><code class="language-text">nix shell github:divnix/std
</code></pre>
<p>With the <code>std</code> binary now available, we can open the TUI with:</p>
<pre><code class="language-text">std
</code></pre>
<p>For our example repository, we're met with:</p>
<p><img src="getting_started/../images/tui.png" alt="The std TUI" /></p>
<p>What we're seeing here is a graphical view of our project. In this case, we have
a single binary located at <code>//example/apps/default</code> which can be run. How does
<code>std</code> know this? Recall that we informed <code>std</code> that we have <code>runnables</code> located
in <code>apps.nix</code>. When <code>std</code> analyzes our repository, it automatically found the
<code>runnable</code> for our example Rust project and is showing us what we can do with it
(i.e., run it).</p>
<p>This may seem trivial, but that's only because our repository is small. The
usefulness of the TUI grows in proportion to the size of our project. As we add
more and more pieces to it, the TUI begins to become an entry point for
contributors to explore our repository.</p>
<p>In addition to the TUI, the <code>std</code> binary has a CLI counterpart that will show
the structure of the repository:</p>
<pre><code class="language-text">$ std list
//example/apps/default:run    --    An example Rust binary which greets the user:  exec this target
</code></pre>
<p>If we wanted to run our binary, we'd use:</p>
<pre><code class="language-text">std //example/apps/default:run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="review"><a class="header" href="#review">Review</a></h1>
<p>Before we continue into more advanced subjects, let's stop for a moment and
review. What have we gained here? First of all, we have standardized where our
binary builds are defined for our repository: <code>/nix/example/apps.nix</code>. If we
want to add additional builds (i.e., a debug binary), we know exactly where to
put it. As a bonus, we don't even need to worry about the system fiasco that
flakes are often criticized for.</p>
<p>Secondly, we have standardized what most of our Nix code &quot;looks&quot; like. The
<code>{inputs, cell}</code> format is deceptively powerful. One of the most significant
sources of complexity in large Nix codebases stems from the question, &quot;How do I
access everything?&quot; In our case:</p>
<ul>
<li>Inputs can be accessed via <code>inputs</code></li>
<li>Anything within our local cell can be accessed via <code>cell</code></li>
<li>Other cells can be accessed via <code>inputs.cells</code></li>
</ul>
<p>Meaning that as long as we adhere to the organizational principles being applied
with <code>std</code>, we don't have to worry about figuring out where to put things and
how to access them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-development-shells-devshells"><a class="header" href="#managing-development-shells-devshells">Managing Development Shells (devshells)</a></h1>
<p>In the remaining chapters of this book, we're going to begin improving the
foundation we laid in the previous chapter. We've already gained a lot by
integrating <code>std</code> into our example Rust project, but there remains significant
room for improvement.</p>
<p>So far, we've seen that <code>std</code> has a lot to offer in terms of bringing
organization to our Nix-infused repositories. In addition to organization, <code>std</code>
also brings with it many quality-of-life improvements. We're going to
investigate the first one in this chapter: development shells.</p>
<h2 id="works-on-my-machine"><a class="header" href="#works-on-my-machine">Works on My Machine</a></h2>
<p>At the risk of beating a dead horse, this section will be a brief review of why
development shells are needed and the benefits they provide to almost any
project. Perhaps the most iconic words used to address this issue are:</p>
<blockquote>
<p>Works on my machine!</p>
</blockquote>
<p>Indeed, this single line has led to a plethora of innovations to address the
lack of reproducibility that has defined the last decade of software. Many
technologies have risen to tackle the issue, but Nix stands as one of the oldest
technologies aimed specifically at tackling this problem.</p>
<p>The main solution Nix employs to tackle reproducible development environments is
<a href="https://nixos.org/manual/nix/stable/command-ref/nix-shell.html">nix-shell</a>. We used this command in the last chapter to quickly enter a shell
environment that had the <code>std</code> binary available. This command has further been
refined by receiving support in the official <a href="https://nixos.wiki/wiki/Flakes#Flake_schema">flake schema</a>. With
flakes, it's now possible to define an entire reproducible <em>development shell</em>
which will include all necessary tools to work on a given project. The idea is
simple: if you want to contribute to a project, load up the development shell
and start making changes. The net result is a dramatic reduction in
system-dependent problems and a smoother contribution experience for a project.</p>
<h2 id="devshell"><a class="header" href="#devshell">Devshell</a></h2>
<p>The wonderful individuals at <a href="https://numtide.com">numtide</a> have taken the idea of development shells
and accelerated productivity even further. The <a href="https://github.com/numtide/devshell">numtide/devshell</a> project builds
upon flake-based development shells by adding several quality-of-life features
that further improve upon a developer's experience. These can be roughly
summarized as follows:</p>
<ul>
<li>MOTD: A custom message of the day can be configured that appears when a user
first enters the development shell. This can be useful for introducing users
to a project and giving some basic instructions for getting started with
contributions.</li>
<li>Custom commands: Repository-specific commands can be configured to bring
uniformity to contributors. For example, a <code>fmt</code> command can be defined which
runs the formatter(s) the same way they may be run in CI.</li>
<li>Menu: A repository-specific menu can be created that is accessed by running
<code>menu</code> from the command-line. The contents of this menu are customizable and
can include custom commands or other binaries that are available in the
environment.</li>
<li>Package management: package management is made significantly easier by
allowing packages to be specified in several different locations. For example,
a custom command could be dependent on a package being available in the
environment and <code>devshell</code> will handle the dependency for you automatically.</li>
</ul>
<p>The <code>std</code> framework provides native support for integrating <code>devshell</code> into our
standardized project. All that's required is a little bit of configuration on
our end and we'll be able to provide a rich development shell for contributors
to use with our example Rust project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-the-devshell-block"><a class="header" href="#adding-the-devshell-block">Adding the Devshell Block</a></h1>
<p>As we begin iterating on our project, we'll come across this common theme: to
add new functionality to our project, simply add new cell blocks. In the case of
<code>devshell</code>, this remains true: to begin, we'll add a new block to our
<code>flake.nix</code>:</p>
<pre><code class="language-nix">{
  inputs.std.url = &quot;github:divnix/std&quot;;
  inputs.nixpkgs.url = &quot;nixpkgs&quot;;
  inputs.rust-overlay.url = &quot;github:oxalica/rust-overlay&quot;;

  outputs = { std, ... } @ inputs:
    std.growOn
      {
        inherit inputs;
        cellsFrom = ./nix;
        cellBlocks = [
          (std.blockTypes.runnables &quot;apps&quot;)

          # The `devshell` type will allow us to have &quot;development shells&quot;
          # available. These are managed by `numtide/devshell`.
          # See: https://github.com/numtide/devshell
          (std.blockTypes.devshells &quot;devshells&quot;)

          # The `function` type is a generic block type that allows us to define
          # some common Nix code that can be used in other cells. In this case,
          # we're defining a toolchain cell block that will contain derivations
          # for the Rust toolchain.
          (std.blockTypes.functions &quot;toolchain&quot;)
        ];
      }
      {
        packages = std.harvest inputs.self [ &quot;example&quot; &quot;apps&quot; ];

        # We want to export our development shells so that the following works
        # as expected:
        #
        # &gt; nix develop
        #
        # Or, we can put the following in a .envrc:
        #
        # use flake
        devShells = std.harvest inputs.self [ &quot;example&quot; &quot;devshells&quot; ];
      };
}
</code></pre>
<p>The first thing to notice is we've added a new input for the <a href="https://github.com/oxalica/rust-overlay">rust-overlay</a>
flake. This flake provides an <code>overlay</code> attribute that we can overlay on top of
<code>nixpkgs</code> to enable fetching specific versions of the <a href="https://rust-lang.github.io/rustup/concepts/toolchains.html">Rust
toolchain</a>. We'll use this below in our <code>toolchain</code> cell block
to make fetching the latest version of the toolchain trivial.</p>
<p>We've added two new cell blocks above: one of the <code>devshells</code> type and the other
of the <code>functions</code> type. Our development shells will be defined in
<code>/nix/cell/devshells.nix</code> and our toolchain will be defined in
<code>/nix/cell/toolchain.nix</code>. The <code>devshells</code> type should be self-explanatory at
this point: this is where we will define the development shells available in our
project. The <code>functions</code> type is a bit unique and serves as a general type for
storing cell-specific Nix expressions. In this case, we're creating a
<em>toolchain</em> cell block that will contain a Nix expression that evaluates to the
latest version of the Rust toolchain.</p>
<p>In addition to adding the above two cell blocks, we've also expanded the second
argument to our <code>growOn</code> function so that the development shells we define are
available under the <code>devShells</code> flake output. This provides compatibility with
the Nix CLI and anyone using <code>nix flake show</code> to inspect the repository.</p>
<h2 id="defining-our-devshell"><a class="header" href="#defining-our-devshell">Defining our Devshell</a></h2>
<p>We're going to define a single development shell in
<code>/nix/example/devshells.nix</code>:</p>
<pre><code class="language-nix"># Just like we place buildables in `apps.nix`, it's standard to place our
# development shells in a `devshells.nix` cell block.
#
# This cell block is used to define the development shells that are available to
# consumers of our repository. If you're not familiar with the idea of a
# development shell, it's essentially a self-contained environment that can be
# configured to provide all the tools and dependencies needed to work on our
# project. It solves the vital problem of, &quot;works on my machine.&quot;
{ inputs
, cell
}:
let
  inherit (inputs) nixpkgs std;
  l = nixpkgs.lib // builtins;
in
# Here we map an attribute set to the `std.std.lib.mkShell` function.
  # This is a small wrapper around the numtide/devshell `mkShell` function and
  # provides integration with `nixago`, which we'll see in a later part. The
  # result of this map is a attribute set where the value is a proper
  # development shell derivation.
l.mapAttrs (_: std.std.lib.mkShell) {
  # This is our only development shell, so we name it &quot;default&quot;. The
  # numtide/devshell `mkShell` function uses modules, so the `{ ... }` here is
  # simply boilerplate.
  default = { ... }: {
    # The structure of this attribute set is defined here:
    # https://github.com/numtide/devshell/tree/master/modules
    #
    # Familiarity with the devshell system is likely valuable here, but it's
    # intuitive enough to understand without it.

    # This is the name of our development shell. When a user enters the shell,
    # a MOTD style heading is printed to stdout with this name.
    name = &quot;example devshell&quot;;

    # Since we're using modules here, we can import other modules into our
    # final configuration. In this case, we import the `std` default development
    # shell profile which will, among other things, automatically include the
    # `std` TUI in our environment.
    imports = [ std.std.devshellProfiles.default ];

    # This is a list of packages that will be available in our development
    # environment. In this case, we're pulling in the rust toolchain from our
    # `toolchains` cell block.
    #
    # Notice the magic here. We can extrapolate the rust toolchain to a separate
    # cell block and then access it from `cell.toolchain`. This is a direct
    # benefit from standardizing our project!
    packages = [
      cell.toolchain.rust.stable.latest.default
    ];

    # This is a list of &quot;commands&quot; that will be available inside our development
    # environment. One of the features of numtide/devshell is that it provides
    # a `menu` command that will list all of the commands we define below. This
    # allows consumers to easily understand what development tasks are available
    # to them from the CLI. For example, running `tests` in side of our shell
    # will in turn call `cargo test` for us.
    commands = [
      {
        name = &quot;tests&quot;;
        command = &quot;cargo test&quot;;
        help = &quot;run the unit tests&quot;;
        category = &quot;Testing&quot;;
      }
    ];
  };
}
</code></pre>
<p>There appears to be a lot going on here, but it's fairly straightforward to
follow. First of all, we have our typical cell block structure at the top of the
file with the <code>inputs</code> and <code>cell</code> arguments. We do some simple setup in the
<code>let</code> statement and then we perform a map, utilizing <code>std.std.lib.mkShell</code> as
the function. The <a href="https://github.com/divnix/std/blob/main/cells/std/lib/default.nix#L10">mkShell</a> function offered by <code>std</code> is a wrapper around the
<a href="https://github.com/numtide/devshell/blob/master/default.nix#L71">mkShell</a> function provided by <code>devshell</code>. The primary benefit of
using the wrapper will be revealed in a future chapter, but for now, it's simple
enough to understand that it does the work of making the development shell
derivation that is consumed by Nix.</p>
<p>The <code>mkShell</code> function accepts a single parameter, a <a href="https://nixos.wiki/wiki/NixOS_modules#Function">module
function</a>. In this case, we don't need access to any of the
standard module arguments, so we can compress them with ellipses.</p>
<p>The available options for the module are <a href="https://github.com/numtide/devshell/tree/master/modules">defined here</a>. The
most common options are discussed below:</p>
<ul>
<li><code>name</code>: The name of the development shell. Appears in the MOTD.</li>
<li><code>packages</code>: A list of Nix packages that should be made available in the
development shell.</li>
<li><code>commands</code>: A list of custom commands that should be made available in the
development shell. The suboptions can be <a href="https://github.com/numtide/devshell/blob/master/modules/commands.nix">found here</a>.</li>
</ul>
<p>In the example above, we define a single development shell (<code>default</code>), give it
a name, add the Rust toolchain from our <code>toolchain</code> cell block (discussed
below), and provide a single custom command which runs our unit tests using
<code>cargo</code>.</p>
<p>It's worth noticing the utility of this expression:</p>
<pre><code class="language-nix">{
    # ...
    packages = [
      cell.toolchain.rust.stable.latest.default
    ];
    # ...
}
</code></pre>
<p>As mentioned in chapter 1, the <code>cell</code> argument allows us to access all the cell
blocks available within our local cell. In this case, we utilize it to access
the <code>toolchain</code> cell block to bring our Rust toolchain expression into the scope
of the development shell. This is a neat trick that <code>std</code> allows us to do!</p>
<p>The remaining <code>imports</code> attribute is a Nix module <a href="https://nixos.wiki/wiki/NixOS_modules#Imports">feature</a> that
allows importing additional modules into our final configuration. Here we import
a development shell profile from the <code>std</code> library which provides us with the
following:</p>
<ul>
<li>Includes the <code>std</code> binary into our development environment for us</li>
<li>Provides a customized MOTD specific to <code>std</code></li>
</ul>
<p>This isn't strictly necessary, and can certainly be omitted.</p>
<h2 id="defining-our-toolchain"><a class="header" href="#defining-our-toolchain">Defining our Toolchain</a></h2>
<p>The last piece we're missing is defining our toolchain cell block. We'll do this
in <code>/nix/example/toolchain.nix</code>:</p>
<pre><code class="language-nix"># This cell block is less idiomatic and is geared towards customizing our
# standardized environment by making an overlayed version of the rust toolchain
# available to our cell. This is the benefit of having some flexibility with how
# we organize our cells and cell blocks.
{ inputs
, cell
}:
{
  # `std` does not support global overlays, so we use `nixpkgs.extend` to make
  # a local overlay.
  # See: https://github.com/divnix/std/issues/117
  rust = (inputs.nixpkgs.extend inputs.rust-overlay.overlays.default).rust-bin;
}
</code></pre>
<p>A theme should start appearing now with the structure of cell blocks. In this
case, we're given a little freedom with the structure of what it produces. The
goal is to create an expression that evaluates to the latest stable version of
the Rust toolchain using the <code>rust-overlay</code> flake we imported in our
<code>flake.nix</code>.</p>
<p>As the comments make note of, <code>std</code> discourages applying overlays globally and
instead recommends defining a local instance of <code>nixpkgs</code> and using the <code>extend</code>
function to apply overlays. This is exactly what we do here, with the result
being we can access the Rust toolchain via <code>rust.stable.latest.default</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-direnv"><a class="header" href="#integrating-direnv">Integrating direnv</a></h1>
<p>The last thing we'll add to improve our newly created development environment is
integration with <a href="https://direnv.net">direnv</a>. This utility provides a critical feature in improving
the experience with Nix development shells. In short, <code>direnv</code> will
automatically evaluate (once explicitly allowed on a per-file basis) any
<code>.envrc</code> files found at the root of a directory (and by nature, all parent
directories).</p>
<p>What these <code>.envrc</code> files do is dependent on their contents. They can be as
basic or advanced as desired. In the case of Nix, one can use <a href="https://github.com/nix-community/nix-direnv">nix-direnv</a> to
automatically enter into a Nix development shell. This is so incredibly common
across the Nix ecosystem that you'll almost always see <code>.envrc</code> files in
Nix-infused repositories.</p>
<p>The <code>std</code> framework provides some additional magic on top of the standard
<code>direnv</code> experience which will not only allow us to select which of our defined
development shells we want to enter automatically but also apply file watchers
to our definitions to automatically reload our environment when the files
change. To accomplish this, we'll add the following to a <code>.envrc</code> file at the
root of our repository:</p>
<pre><code class="language-bash">#! /bin/sh
# This file is sourced by direnv when entering the directory. The content below
# is pulled from: https://divnix.github.io/std/guides/envrc.html

source &quot;$(
    nix eval \
        --no-update-lock-file \
        --no-write-lock-file \
        --no-warn-dirty \
        --accept-flake-config \
        .#__std.direnv_lib 2&gt;/dev/null
)&quot;

# Here we can select which development environment is used by `direnv`. We only
# have one in this case, and we called it default.
# See: /nix/std-example/devshells.nix).
use std nix //example/devshells:default
</code></pre>
<p>With this, and <code>direnv</code> installed/configured, we can <code>cd</code> into our repository
root and be automatically dropped into our newly minted development shell:</p>
<pre><code class="language-text">$ direnv allow
direnv: loading ~/code/nix/std-book-example/.envrc
direnv: using std nix //example/devshells:default
direnv: Watching: nix/example/devshells.nix

🔨 Welcome to example devshell 🔨

To autocomplete 'std' in bash, zsh, oil: source &lt;(std _carapace)
More shells: https://rsteube.github.io/carapace/carapace/gen/hiddenSubcommand.html


[Testing]

  tests - run the unit tests

[general commands]

  menu  - prints this menu
  std   - A tui for projects that conform to Standard

direnv: export +DEVSHELL_DIR +NIXPKGS_PATH +PRJ_DATA_DIR +PRJ_ROOT ~PATH ~XDG_DATA_DIRS
</code></pre>
<p>As expected, <code>std</code> is available and we can even see our example <code>tests</code> command
in the menu. Let's give it a try:</p>
<pre><code class="language-text">$ tests
Finished test [unoptimized + debuginfo] target(s) in 0.04s
     Running unittests src/main.rs (target/debug/deps/example-965805a32576c369)

running 1 test
test test_say_hello ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="review-1"><a class="header" href="#review-1">Review</a></h1>
<p>Let's take stock of what we've been afforded with these changes.</p>
<ul>
<li>We took advantage of <code>std</code>'s integration with <code>numtide/devshell</code> and added a
default development shell to our repository</li>
<li>We created a nice MOTD for our repository, welcoming contributors and making
them aware of <code>std</code> and our custom commands</li>
<li>We added a custom command for running our tests with <code>cargo</code></li>
<li>We provided contributors with the latest version of the Rust toolchain</li>
</ul>
<p>Finally, to wrap things with a bow, we integrated <code>direnv</code> to automagically load
us into our new development shell when we <code>cd</code> into our repository root. This is
no small feat! The best part is we stayed within <code>std</code> the whole time and yet
were still afforded all of these quality-of-life improvements.</p>
<p>The organizational structure provided by <code>std</code> is a huge boon to productivity,
but so are the quality-of-life improvements. Contributing to our humble example
project just became much easier with development shells, and we'll continue this
theme of improvement in the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-configurations"><a class="header" href="#managing-configurations">Managing Configurations</a></h1>
<p>In the last chapter, we saw how the integration with <code>numtide/devshell</code> allows
us to easily integrate feature-rich development environments into our
repository. These allow contributors to quickly get up to speed with the tools
that are required to contribute to our repository and provide a lot towards
solving the &quot;works on my machine&quot; problem.</p>
<p>In this chapter, we're going to look at another integration: <a href="https://github.com/nix-community/nixago">Nixago</a>.</p>
<h2 id="an-introduction-to-nixago"><a class="header" href="#an-introduction-to-nixago">An Introduction to Nixago</a></h2>
<p>Modern repositories rely on a lot of modern tools for providing things like
linting, auditing, formatting, compiling, releasing, etc. Sometimes one tool can
tackle multiple tasks, but for the most part we often end up needing several to
cover the whole spectrum. To make matters worse, many of these tools bring with
them their own configuration with little room for interoperability between them.</p>
<p>Nixago was designed to address this problem by doing two things:</p>
<ol>
<li>Bringing configuration data back into Nix</li>
<li>Dynamically generating configuration files</li>
</ol>
<h3 id="managing-configurations-with-nix"><a class="header" href="#managing-configurations-with-nix">Managing Configurations with Nix</a></h3>
<p>The first benefit that Nixago brings is it allows us to generate our
configuration files using pure Nix code. This allows us to do many interesting
things, especially when our entire repository is already wired up by Nix using
<code>std</code>.</p>
<p>For example, we can apply convenient transformations to data structures or bring
in data from other parts of the repository to inform how a specific tool should
be configured. The <code>std</code> <a href="https://github.com/divnix/std/blob/main/cells/std/nixago/conform.nix">integration</a> for <a href="https://github.com/siderolabs/conform">conform</a> does
this by automatically configuring the conventional commit policy using the cell
names as subjects. This is just one example of many possibilities that can be
put together using <code>std</code>'s Nixago integration.</p>
<h3 id="dynamic-generation"><a class="header" href="#dynamic-generation">Dynamic Generation</a></h3>
<p>The second benefit that Nixago brings is that configuration files are
dynamically generated. When a user first enters into a development shell that
has been configured with Nixago support, it will automatically run its
pre-generated shell hooks which will generate the required configuration files
and write them to the repository directory. Most of the time, these files are
simply symlinks that point back to the Nix store (and are automatically added to
<code>.gitignore</code>). However, an option can be specified which switches these to hard
copies which can then be committed into revision control (to support CI for
example).</p>
<h2 id="integration"><a class="header" href="#integration">Integration</a></h2>
<p>The <code>std</code> framework makes it easy to integrate Nixago into our repository. It
provides a <a href="https://github.com/divnix/std/blob/main/src/blocktypes/nixago.nix">cell block type</a> which provides direct integration
with the <code>devshell</code> cell block. This is required, because Nixago relies on shell
hooks to generate files, and the <code>devshell</code> integration will ensure the hooks
are run when we enter the environment.</p>
<p>In the remainder of this chapter, we'll work on setting up the Nixago
integration to configure a few common tools that will prove useful to our
development experience.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-a-nixago-block"><a class="header" href="#adding-a-nixago-block">Adding a Nixago Block</a></h1>
<p>As with any cell block, we'll first add it to our <code>flake.nix</code>:</p>
<pre><code class="language-nix">{
  inputs.std.url = &quot;github:divnix/std&quot;;
  inputs.nixpkgs.url = &quot;nixpkgs&quot;;
  inputs.rust-overlay.url = &quot;github:oxalica/rust-overlay&quot;;

  outputs = { std, ... } @ inputs:
    std.growOn
      {
        inherit inputs;
        cellsFrom = ./nix;
        cellBlocks = [
          (std.blockTypes.runnables &quot;apps&quot;)
          (std.blockTypes.devshells &quot;devshells&quot;)
          (std.blockTypes.functions &quot;toolchain&quot;)

          # The `nixago` type is used for holding Nixago configurations. We name
          # it configs to remove some ambuiguity.
          (std.blockTypes.nixago &quot;configs&quot;)
        ];
      }
      {
        packages = std.harvest inputs.self [ [ &quot;example&quot; &quot;apps&quot; ] ];
        devShells = std.harvest inputs.self [ &quot;example&quot; &quot;devshells&quot; ];
      };
}
</code></pre>
<p>This is a fairly trivial addition, the only thing worth noting is that we call
it <code>configs</code> to reduce ambiguity because most people are not aware of what
Nixago does.</p>
<h2 id="defining-the-block"><a class="header" href="#defining-the-block">Defining the Block</a></h2>
<p>The cell block is where the meat of our configuration lies. We'll add the
following to <code>/cells/example/configs.nix</code>:</p>
<pre><code class="language-nix"># This cell block holds our Nixago expressions for generating configuration
# files for the various tools we want to configure in our repository. We title
# it `configs.nix` because Nixago is less well-known and this name points to the
# purpose of the cell block.
#
# For an introduction to Nixago, see here:
# https://nix-community.github.io/nixago/
{ inputs
, cell
}:
let
  inherit (inputs) nixpkgs std;
  l = nixpkgs.lib // builtins;
in
# The structure is an attribute set where the value is an attribute set that
  # is ultimately passed to the `make`[1] function from Nixago. The available
  # arguments for the `make` function can be seen here[2].
  #
  # `std` allows us to pass additional pass-through arguments that can influence
  # the behavior of our development shells. This is primarily used so we can
  # include the necessary packages for the tools we want to configure into the
  # development environment.
  #
  # Additionally, `std` automatically includes any shell hooks generated by Nixago
  # into the appropriate `devshell` option. This is ultimately what allows Nixago
  # to generate the configurations when we enter the development shell.
  #
  # [1]: https://github.com/nix-community/nixago/blob/master/lib/make.nix
  # [2]: https://github.com/nix-community/nixago/blob/master/modules/request.nix
{
  # The `std` framework ships with some &quot;pre-configured&quot; services that we can
  # import and use here. For a list of all of them, see here[1]. These are setup
  # such that we can use a functor to dynamically extend them with additional
  # attributes or overrides. This is why they appear to look like functions.
  #
  # In most cases, when using these pre-configured services, we only need to be
  # concerned with setting the `configData` attribute. This is what ultimately
  # ends up in the generated configuration file and is dependent on what tool
  # is being configured.
  #
  # Conform[2] is a tool that allows us to enforce policies on our commit
  # messages. We configure it here to only allow commits that follow the
  # Conventional Commits specification[3].
  #
  # [1]: https://github.com/divnix/std/tree/main/cells/std/nixago
  # [2]: https://github.com/siderolabs/conform
  # [3]: https://www.conventionalcommits.org/en/v1.0.0/
  conform = std.std.nixago.conform {
    # The configuration of Conform is a bit different than the expected file
    # format. This is to prevent excessive nested attribute sets. In this case,
    # we only need to specify either a `commit` or `license` parent attribute
    # and then the child contents match what is specified in the Conform README.
    configData = {
      commit = {
        header = { length = 89; };
        conventional = {
          # Only allow these types of conventional commits (inspired by Angular)
          types = [
            &quot;build&quot;
            &quot;chore&quot;
            &quot;ci&quot;
            &quot;docs&quot;
            &quot;feat&quot;
            &quot;fix&quot;
            &quot;perf&quot;
            &quot;refactor&quot;
            &quot;style&quot;
            &quot;test&quot;
          ];
        };
      };
    };
  };
  # Lefthook is a pre-commit hook manager.
  lefthook = std.std.nixago.lefthook {
    configData = {
      commit-msg = {
        commands = {
          # Runs conform on commit-msg hook to ensure commit messages are
          # compliant.
          conform = {
            run = &quot;${nixpkgs.conform}/bin/conform enforce --commit-msg-file {1}&quot;;
          };
        };
      };
      pre-commit = {
        commands = {
          # Runs treefmt on pre-commit hook to ensure checked-in source code is
          # properly formatted.
          treefmt = {
            run = &quot;${nixpkgs.treefmt}/bin/treefmt {staged_files}&quot;;
          };
        };
      };
    };
  };
  # Prettier is a multi-language code formatter.
  prettier = std.std.lib.mkNixago {
    # We mainly use it here to format the Markdown in our README.
    configData = {
      printWidth = 80;
      proseWrap = &quot;always&quot;;
    };
    output = &quot;.prettierrc&quot;;
    format = &quot;json&quot;;
  };
  # Treefmt is an aggregator for source code formatters. Our codebase has
  # markdown, Nix, and Rust, so we configure a formatter for each.
  treefmt = std.std.nixago.treefmt {
    configData = {
      formatter = {
        nix = {
          command = &quot;nixpkgs-fmt&quot;;
          includes = [ &quot;*.nix&quot; ];
        };
        prettier = {
          command = &quot;prettier&quot;;
          options = [ &quot;--write&quot; ];
          includes = [ &quot;*.md&quot; ];
        };
        rustfmt = {
          command = &quot;rustfmt&quot;;
          options = [ &quot;--edition&quot; &quot;2021&quot; ];
          includes = [ &quot;*.rs&quot; ];
        };
      };
    };
    # This is the pass-through feature where we can pass attributes to devshell.
    # In this case, we're asking devshell to include the `nixpkgs-fmt` and
    # `prettier` packages in the development environment. The `rustfmt` package
    # is already included within the Rust toolchain (see toolchain.nix).
    packages = [
      nixpkgs.nixpkgs-fmt
      nixpkgs.nodePackages.prettier
    ];
  };
}
</code></pre>
<p>This is significantly more code, but a majority of it is the actual
configuration data we're using to generate our files.</p>
<p>The output structure of the cell block is an attribute set where the value is
another attribute set that must conform to two things:</p>
<ol>
<li>The <a href="https://github.com/nix-community/nixago/blob/master/modules/request.nix">module structure</a> enforced by Nixago</li>
<li>Any additional pass-through data, which in this case means data intended for
<code>devshell</code></li>
</ol>
<h3 id="module-structure"><a class="header" href="#module-structure">Module Structure</a></h3>
<p>The module structure is fairly easy to grasp and a quick overview can be seen in
the <a href="https://nix-community.github.io/nixago/quick_start.html">Nixago quick start guide</a>. The three main options are:</p>
<ol>
<li><code>configData</code>: The raw configuration data used to generate the output file</li>
<li><code>output</code>: The name of the output file</li>
<li><code>format</code>: The format of the output file</li>
</ol>
<p>There are a few additional advanced options, but the above three options are
enough to cover a majority of use cases.</p>
<p>The <code>std</code> framework provides several &quot;pre-configured&quot; expressions that we can
make use of to lessen the verbosity of our cell block. These expressions can be
<a href="https://github.com/divnix/std/tree/main/cells/std/nixago">found here</a>. Attentive readers will notice that it appears we are
&quot;calling&quot; these expressions as if they were functions. This is because they use
<a href="https://github.com/NixOS/nixpkgs/issues/11233">functors</a> to allow dynamically merging/overriding the arguments passed to them.
So in many of the examples seen in our code, we're essentially extending the
existing structure given to us by <code>std</code> and adding our raw configuration data to
it. It's not strictly necessary to do this, we could just define the whole
structure ourselves, but using these shortcuts helps us type a bit less.</p>
<h3 id="pass-through"><a class="header" href="#pass-through">Pass-Through</a></h3>
<p>To get our Nixago configurations to generate, we must pass off the shell hooks
to <code>devshell</code>. We'll tackle this part soon, but the important thing to
understand is that these data structures will eventually pass through to
<code>devshell</code>. What this means is that we can add additional attributes to our data
structure that will in turn provide additional configuration to <code>devshell</code>.</p>
<p>If you examine the <code>treefmt</code> configuration in our example, you'll see that it
also includes the <code>packages</code> attribute which is not a part of the Nixago module
structure. Nixago will ignore this attribute, but when <code>devshell</code> sees it, it
will automatically include those packages in our environment. This allows us to
define our dependency as close to our configuration as possible while also
ensuring our configuration works as expected (i.e. <code>treefmt</code> needs <code>prettier</code> to
work as expected).</p>
<h2 id="the-tools"><a class="header" href="#the-tools">The Tools</a></h2>
<p>The remainder of the code is responsible for configuring the actual tools we'll
be using. Each of these will be briefly discussed below.</p>
<h3 id="conform"><a class="header" href="#conform">Conform</a></h3>
<p>The <a href="https://github.com/siderolabs/conform">conform</a> tool allows us to specify policies that will be enforced against
our commits. This is an invaluable tool in open-source projects and can help
bring uniformity to commit messages and improve the generation of change logs.</p>
<p>In our case, we're specifying that commit message headers can be no longer than
89 characters and that the message itself must conform (ha!) to the
<a href="https://www.conventionalcommits.org/en/v1.0.0/">conventional commit specification</a>. Additionally, the <em>type</em> section of the
conventional commit header must be one of the items given in the list (the list
itself is inspired by the <a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit">Angular project</a>).</p>
<h3 id="lefthook"><a class="header" href="#lefthook">Lefthook</a></h3>
<p>The <a href="https://github.com/evilmartians/lefthook">lefthook</a> tool automatically manages <a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks">git hooks</a> for us. These
are often referred to as pre-commit hooks and have been a best practice in many
projects for reducing the feedback cycle when developing against a project.</p>
<p>In our case, we use <code>lefthook</code> to enforce our commit messages using the policy
specified with <code>conform</code>. Additionally, we automatically call <code>treefmt</code> on the
files being checked in to ensure that all of our revision-controlled source code
is properly formatted.</p>
<h3 id="prettier"><a class="header" href="#prettier">Prettier</a></h3>
<p>The <a href="https://prettier.io">prettier</a> tool is a general-purpose code formatter that supports several
languages.</p>
<p>In our case, we're simply using it to format our markdown files. The primary
benefit is that it can help enforce the 80-character line limit being imposed
across all of our code.</p>
<h3 id="treefmt"><a class="header" href="#treefmt">Treefmt</a></h3>
<p>The <a href="https://github.com/numtide/treefmt">treefmt</a> tool acts as an aggregator for code formatters. Instead of having
to call each formatter individually, we instruct <code>treefmt</code> which formatters we
want to run on which types of files and it will handle the rest for us.</p>
<p>In our case, we're adding formatters for the three primary languages that exist
in our repository: Rust, Nix, and Markdown.</p>
<h2 id="devshell-integration"><a class="header" href="#devshell-integration">Devshell Integration</a></h2>
<p>As mentioned earlier, the last thing we need to do is to inform our <code>devshell</code>
configuration about our newly added Nixago configurations. We'll add the
following to our <code>/nix/example/devshells.nix</code> file:</p>
<pre><code class="language-nix">{ inputs
, cell
}:
let
  inherit (inputs) nixpkgs std;
  l = nixpkgs.lib // builtins;
in
l.mapAttrs (_: std.std.lib.mkShell) {
  default = { ... }: {
    # ...

    # Nixago uses shell hooks for generating configuration files. In order for
    # that to work, devshell must add them to its own configuration. To ensure
    # this happens, we specify the configurations we would like generated using
    # the `nixago` attribute.
    nixago = [
      cell.configs.conform
      cell.configs.lefthook
      cell.configs.prettier
      cell.configs.treefmt
    ];

    # ...
  };
}
</code></pre>
<p>With this complete, we can now reload our development shell and watch Nixago
generate all of our configuration files for us:</p>
<pre><code class="language-text">$ direnv reload
# ...
nixago: updating repositoriy files
nixago: '.conform.yaml' link updated
nixago: '.conform.yaml' added to .gitignore
nixago: 'lefthook.yaml' link updated
nixago: 'lefthook.yaml' added to .gitignore
nixago: '.prettierrc' link updated
nixago: '.prettierrc' added to .gitignore
nixago: 'treefmt.toml' link updated
nixago: 'treefmt.toml' added to .gitignore
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="review-2"><a class="header" href="#review-2">Review</a></h1>
<p>Many of the improvements we have gained in this chapter have come from the tools
we've now employed to improve our overall development experience; however, don't
miss how easy it was to automatically have these tools:</p>
<ol>
<li>Dynamically configured using Nix</li>
<li>Configuration files automatically managed by Nixago.</li>
<li>Binaries automatically included in the shell environment</li>
</ol>
<p>The integration between <code>std</code>, Nixago, and <code>devshell</code> has afforded us a great
degree of flexibility for bringing in and configuring tools that will help
improve our experience. The organizational model provided by <code>std</code> serves as the
glue that binds these all together and allows our repository to continue to add
useful tools without the risk of becoming too hard to maintain or reproduce.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/mermaid.min.js"></script>
        <script type="text/javascript" src="theme/mermaid-init.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
